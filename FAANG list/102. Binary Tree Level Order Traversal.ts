// Дан корень бинарного дерева, необходимо вернуть уровень обхода значений его узлов (слева направо, уровень за уровнем).

// Пример 1:
// Вход: root = [3,9,20,null,null,15,7]
// Выход: [[3],[9,20],[15,7]]

// Пример 2:
// Вход: root = [1]
// Выход: [[1]]

// Пример 3:
// Вход: root = []
// Выход: [] 

// Ограничения:
// Количество узлов в дереве находится в диапазоне [0, 2000].
// -1000 <= Node.val <= 1000


//   Definition for a binary tree node.
class TreeNode {
    val: number
    left: TreeNode | null
    right: TreeNode | null
    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
        this.val = (val === undefined ? 0 : val)
        this.left = (left === undefined ? null : left)
        this.right = (right === undefined ? null : right)
    }
}

//Решение

// - Определение функции: Функция `levelOrder` принимает корень дерева `root` и возвращает двумерный массив чисел, представляющий уровни дерева.
function levelOrder(root: TreeNode | null): number[][] {

    // - Проверка на `null`: Если `root` равен `null`, это означает, что дерево пустое. В этом случае функция возвращает пустой массив.
    if (!root) return [];

    // - Инициализация очереди: Создаём очередь `q` и добавляем в неё корень дерева. Очередь будет использоваться для обхода узлов уровень за уровнем.
    let q: (TreeNode | null)[] = [root];

    // - Инициализация результата: Создаём массив `res`, который будет хранить значения узлов для каждого уровня.
    let res: number[][] = [];

    // - Основной цикл: Пока очередь не пуста, продолжаем обработку.
    while (q.length > 0) {
        // - Определение размера уровня: `levelSize` хранит количество узлов на текущем уровне. Это позволяет обработать все узлы текущего уровня до перехода к следующему.
        let levelSize = q.length;

        // - Инициализация текущего уровня: Создаём массив `currentLevel` для хранения значений узлов текущего уровня.
        let currentLevel: number[] = [];

        // - Цикл по узлам текущего уровня: Проходим по всем узлам текущего уровня.
        for (let i = 0; i < levelSize; i++) {
            // - Извлечение узла: Извлекаем первый узел из очереди.
            let node = q.shift();

            // - Проверка на `null`: Убедимся, что `node` не равен `null`.
            if (node) {
                // - Добавление значения узла: Добавляем значение узла в `currentLevel`.
                currentLevel.push(node.val);
                // - Добавление потомков в очередь: Если у узла есть левый или правый потомок, добавляем их в очередь для обработки на следующем уровне.
                node.left && q.push(node.left);
                node.right && q.push(node.right);
            }
        }
        // - Добавление уровня в результат: После обработки всех узлов текущего уровня добавляем `currentLevel` в `res`.
        res.push(currentLevel);
    }
    // - Возврат результата: Возвращаем `res`, который содержит значения узлов для каждого уровня дерева.
    return res;
};
