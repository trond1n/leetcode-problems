// 199. Binary Tree Right Side View
// Дан корень бинарного дерева. Представьте, что вы стоите с правой стороны от дерева. Верните значения узлов, которые вы можете увидеть, упорядоченные сверху вниз.

function rightSideView(root: TreeNode | null): number[] {
    // Если дерево пустое (корень равен null), возвращаем пустой массив
    if (!root) return [];

    // Инициализируем стек с корневым узлом и его уровнем (0)
    const stack = [{ node: root, level: 0 }];

    // Массив для хранения результата (значения узлов, видимых справа)
    const res: number[] = [];

    // Пока стек не пуст, продолжаем обработку
    while (stack.length) {
        // Извлекаем элемент из начала стека
        const el = stack.shift();

        if (el) {
            // Записываем значение текущего узла на его уровень в массив результата
            // Это перезаписывает значение для данного уровня, оставляя только последнее (самое правое)
            res[el.level] = el.node.val;

            // Если у текущего узла есть левый потомок, добавляем его в стек с увеличенным уровнем
            if (el.node.left) {
                stack.push({ node: el.node.left, level: el.level + 1 });
            }

            // Если у текущего узла есть правый потомок, добавляем его в стек с увеличенным уровнем
            if (el.node.right) {
                stack.push({ node: el.node.right, level: el.level + 1 });
            }
        }
    }

    // Возвращаем массив значений, видимых с правой стороны дерева
    return res;
};

// Оценка временной сложности (О-большое) для данного алгоритма зависит от того, как он обходит дерево. 
// В данном случае используется обход в ширину (BFS), где каждый узел дерева посещается ровно один раз.
// Временная сложность (Time Complexity): O(n), где n — количество узлов в дереве. Это связано с тем, что каждый узел добавляется в стек и обрабатывается один раз.
// Пространственная сложность (Space Complexity): O(n), // поскольку в худшем случае (когда дерево является полностью несбалансированным и представляет собой вырожденное дерево) 
// все узлы могут находиться в стеке одновременно.

// Таким образом, алгоритм имеет линейную временную и пространственную сложность относительно количества узлов в дереве.
